{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "adfmappoc"
		},
		"AzurePostgreSql1_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'AzurePostgreSql1'"
		},
		"AzurePostgreSql2_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'AzurePostgreSql2'"
		},
		"AzurePostgreSql3_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'AzurePostgreSql3'"
		},
		"OutputLinkedService_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'OutputLinkedService'"
		},
		"Pointsinput_linkedservice_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'Pointsinput_linkedservice'"
		},
		"PostgreSql1_Rakesh_Fra_Admin_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'PostgreSql1_Rakesh_Fra_Admin'"
		},
		"PostgreSql1_Rakesh_Ind_Postal_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'PostgreSql1_Rakesh_Ind_Postal'"
		},
		"linkedservice_Input_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'linkedservice_Input'"
		},
		"pointoutput_linkedService_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'pointoutput_linkedService'"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/allpoints')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "allpoints",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "allpointsflow",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"point": {},
									"pointsink": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime1",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/allpointsflow')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pipeline1')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "BinarySource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true
								},
								"formatSettings": {
									"type": "BinaryReadSettings"
								}
							},
							"sink": {
								"type": "BinarySink",
								"storeSettings": {
									"type": "AzureBlobStorageWriteSettings"
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "dataset_Input",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "dataset_output",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/dataset_Input')]",
				"[concat(variables('factoryId'), '/datasets/dataset_output')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pipeline2')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "dataflow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow1",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"pointsource": {},
									"pointdestination": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime1",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow1')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pipeline3')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "persondataflow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow2",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"person1": {},
									"person2": {},
									"person12": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pipeline4')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "dataflow3",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow3",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"points": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pipeline5')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df6",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow6",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source1": {},
									"test": {},
									"test2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow6')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_admin_center_admin_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "OSM point > postal point",
				"activities": [
					{
						"name": "df_admin_center_admin_process",
						"description": "OSM point > area center",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_admin_center_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmpoint": {},
									"pointstagging": {},
									"postalpointstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "AdminProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-30T13:18:40Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_admin_center_admin_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_admin_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_point_admin_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_point_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmnode": {},
									"pointstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "df_admin_center_admin_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "df_point_admin_process",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_admin_center_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmpoint": {},
									"pointstagging": {},
									"postalpointstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "df_area_polygon_admin_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "df_admin_center_admin_process",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_area_polygon_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmpolygon": {},
									"polygonstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "df_addressable_area_stagging",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "df_area_polygon_admin_process",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_addressable_area_stagging",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"admincenter": {},
									"label": {},
									"releation": {},
									"polygonstagging": {},
									"addressableareastagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "df_way_point_agg_admin_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "df_addressable_area_stagging",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_way_point_agg_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"ways": {},
									"pointstagging": {},
									"linepointagg": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "df_line_admin_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "df_way_point_agg_admin_process",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_line_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"linepointagg": {},
									"lines": {},
									"aggtestfinal": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "df_lines_area_admin_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "df_line_admin_process",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_lines_area_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"rels": {},
									"addressableareastagging": {},
									"lineareastagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "AdminProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-07-01T17:47:39Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_point_admin_process')]",
				"[concat(variables('factoryId'), '/dataflows/df_admin_center_admin_process')]",
				"[concat(variables('factoryId'), '/dataflows/df_area_polygon_admin_process')]",
				"[concat(variables('factoryId'), '/dataflows/df_addressable_area_stagging')]",
				"[concat(variables('factoryId'), '/dataflows/df_way_point_agg_admin_process')]",
				"[concat(variables('factoryId'), '/dataflows/df_line_admin_process')]",
				"[concat(variables('factoryId'), '/dataflows/df_lines_area_admin_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_area_polygon_admin_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "osm polygon > postal polygon",
				"activities": [
					{
						"name": "df_area_polygon_admin_process",
						"description": "osm polygon > postal polygon",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_area_polygon_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmpolygon": {},
									"polygonstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "AdminProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-30T13:35:39Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_area_polygon_admin_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_area_stagging')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_area_stagging",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_area_stagging",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmarea": {},
									"polygonstagging": {},
									"postalpointstaging": {},
									"areastagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_area_stagging')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_df_addressable_area_stagging')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_addressable_area_stagging",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_addressable_area_stagging",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"admincenter": {},
									"label": {},
									"releation": {},
									"polygonstagging": {},
									"addressableareastagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "AdminProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-07-01T08:58:35Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_addressable_area_stagging')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_df_ways_test')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_ways_test",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_ways_test",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"ways": {},
									"pointstagging": {},
									"source1": {},
									"waypointstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_ways_test')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_line_admin_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_line_admin_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_line_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"linepointagg": {},
									"lines": {},
									"aggtestfinal": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "AdminProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:28:12Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_line_admin_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_line_postal_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_line_postal_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_line_postal_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"linepointagg": {},
									"points": {},
									"aggtestfinal": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "PostalProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-28T13:17:29Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_line_postal_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_linegeoom')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_linegeom",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_linegeom",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"aggtest": {},
									"points": {},
									"aggtestfinal": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_linegeom')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_lines_area')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_lines_area",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_lines_area",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"rels": {},
									"postalareastagging": {},
									"lineareastagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_lines_area')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_lines_area_admin_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_lines_area_admin_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_lines_area_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"rels": {},
									"addressableareastagging": {},
									"lineareastagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "AdminProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:28:12Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_lines_area_admin_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_lines_area_postal_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_lines_area_postal_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_lines_area_postal_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"rels": {},
									"postalareastagging": {},
									"lineareastagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "PostalProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-28T13:20:31Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_lines_area_postal_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_linestagging')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_ways",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_ways",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"ways": {},
									"pointstagging": {},
									"lines": {},
									"linestagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_ways')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_point_admin_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Populate Point staging - OSM Node data  > Point staging",
				"activities": [
					{
						"name": "df_point_admin_process",
						"description": "Populate Point staging - OSM Node data  > Point staging",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_point_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmnode": {},
									"pointstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "AdminProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:28:12Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_point_admin_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_point_postal_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Populate Point staging - OSM Node data  > Point staging",
				"activities": [
					{
						"name": "df_point_postal_process",
						"description": "Populate Point staging - OSM Node data  > Point staging",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_point_postal_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmnode": {},
									"pointstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "PostalProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-28T12:47:06Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_point_postal_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_pointstagging')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_point_stagging",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_point_stagging",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmnode": {},
									"pointstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_point_stagging')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_pointvad')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_point_vad",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_point_vad",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"pointstagging": {},
									"poindvad": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_point_vad')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_polygonstagging')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_postalarea_polygon_stagging",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_postalarea_polygon_stagging",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmpolygon": {},
									"polygonstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_postalarea_polygon_stagging')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_postal')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "pl_point_postal_process",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_point_postal_process",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "pl_postal_point_postal_process",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "pl_point_postal_process",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_postal_point_postal_process",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "pl_postal_area_polygon_postal_process",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "pl_postal_point_postal_process",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_postal_area_polygon_postal_process",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "pl_postal_area_postal_porcess",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "pl_postal_area_polygon_postal_process",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_postal_area_postal_porcess",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "pl_way_point_agg_postal_process",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "pl_postal_area_postal_porcess",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_way_point_agg_postal_process",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "pl_line_postal_process",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "pl_way_point_agg_postal_process",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_line_postal_process",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "pl_lines_area_postal_process",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "pl_line_postal_process",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_lines_area_postal_process",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "PostalProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-28T14:20:15Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_point_postal_process')]",
				"[concat(variables('factoryId'), '/pipelines/pl_postal_point_postal_process')]",
				"[concat(variables('factoryId'), '/pipelines/pl_postal_area_polygon_postal_process')]",
				"[concat(variables('factoryId'), '/pipelines/pl_postal_area_postal_porcess')]",
				"[concat(variables('factoryId'), '/pipelines/pl_way_point_agg_postal_process')]",
				"[concat(variables('factoryId'), '/pipelines/pl_line_postal_process')]",
				"[concat(variables('factoryId'), '/pipelines/pl_lines_area_postal_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_postal_area_admin_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "OSM releation > Polygon > Postal Area",
				"activities": [
					{
						"name": "df_postal_area_admin_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_postal_area_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmarea": {},
									"polygonstagging": {},
									"postalpointstaging": {},
									"areastagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-07-01T19:19:23Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_postal_area_admin_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_postal_area_polygon_postal_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "osm polygon > postal polygon",
				"activities": [
					{
						"name": "df_postalarea_polygon_postal_process",
						"description": "osm polygon > postal polygon",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_postalarea_polygon_postal_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmpolygon": {},
									"polygonstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "PostalProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-28T12:55:59Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_postalarea_polygon_postal_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_postal_area_postal_porcess')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "OSM releation > Polygon > Postal Area",
				"activities": [
					{
						"name": "df_postal_area_postal_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_postal_area_postal_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmarea": {},
									"polygonstagging": {},
									"postalpointstaging": {},
									"areastagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "PostalProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-28T13:01:24Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_postal_area_postal_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_postal_point_postal_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "OSM point > postal point",
				"activities": [
					{
						"name": "df_postal_point_postal_process",
						"description": "OSM point > postal point",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_postal_point_postal_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmpoint": {},
									"pointstagging": {},
									"postalpointstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "PostalProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-28T12:51:41Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_postal_point_postal_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_postalpointstagging')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_postalpoint_stagging",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_postalpoint_stagging",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"osmpoint": {},
									"pointstagging": {},
									"postalpointstagging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_postalpoint_stagging')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_way_point_agg_admin_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_way_point_agg_admin_process",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_way_point_agg_admin_process",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"ways": {},
									"pointstagging": {},
									"linepointagg": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "AdminProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:28:12Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_way_point_agg_admin_process')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_way_point_agg_postal_process')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_way_point_agg",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_way_point_agg",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"ways": {},
									"pointstagging": {},
									"lines": {},
									"aggtest": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "PostalProcessPipeline"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-28T13:17:29Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_way_point_agg')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/points')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow4",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"points": {},
									"pointsink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow4')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/postalpoint')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "dataflow5",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow5",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"postal": {},
									"pointvad": {},
									"postalpointvadsink": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime1",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow5')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/uuidrraytest')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "uuidarraytest",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_test_uuidarray",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"ways": {},
									"pointstagging": {},
									"lines": {},
									"aggtest": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Test"
				},
				"annotations": [],
				"lastPublishTime": "2022-06-29T11:33:46Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_test_uuidarray')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzurePostgredataset2')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzurePostgreSql2",
					"type": "LinkedServiceReference",
					"parameters": {
						"DbName1": "postgres"
					}
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [],
				"typeProperties": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/PointOutputDataSet')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "pointoutput_linkedService",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "osm_id",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "access",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "addr:housename",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "addr:housenumber",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "addr:interpolation",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "admin_level",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "aerialway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "aeroway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "amenity",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "area",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "barrier",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bicycle",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "brand",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bridge",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "boundary",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "building",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "capital",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "construction",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "covered",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "culvert",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "cutting",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "denomination",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "disused",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "ele",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "embankment",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "foot",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "generator:source",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "harbour",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "highway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "historic",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "horse",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "intermittent",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "junction",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "landuse",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "layer",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "leisure",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "lock",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "man_made",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "military",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "motorcar",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "name",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "natural",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "office",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "oneway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "operator",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "place",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "population",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "power",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "power_source",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "public_transport",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "railway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "ref",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "religion",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "route",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "service",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "shop",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "sport",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "surface",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "toll",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tourism",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tower:type",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tunnel",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "water",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "waterway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "wetland",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "width",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "wood",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "z_order",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tags",
						"type": "USER-DEFINED",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "way",
						"type": "USER-DEFINED",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "planet_osm_point_test"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/pointoutput_linkedService')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/PointsInputDataSet')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "Pointsinput_linkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "osm_id",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "access",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "addr:housename",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "addr:housenumber",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "addr:interpolation",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "admin_level",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "aerialway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "aeroway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "amenity",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "area",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "barrier",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bicycle",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "brand",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bridge",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "boundary",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "building",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "capital",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "construction",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "covered",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "culvert",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "cutting",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "denomination",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "disused",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "ele",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "embankment",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "foot",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "generator:source",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "harbour",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "highway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "historic",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "horse",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "intermittent",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "junction",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "landuse",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "layer",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "leisure",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "lock",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "man_made",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "military",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "motorcar",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "name",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "natural",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "office",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "oneway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "operator",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "place",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "population",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "power",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "power_source",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "public_transport",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "railway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "ref",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "religion",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "route",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "service",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "shop",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "sport",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "surface",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "toll",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tourism",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tower:type",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tunnel",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "water",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "waterway",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "wetland",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "width",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "wood",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "z_order",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tags",
						"type": "USER-DEFINED",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "way",
						"type": "USER-DEFINED",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "planet_osm_point"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/Pointsinput_linkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataset_Input')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "linkedservice_Input",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "data.txt",
						"folderPath": "input",
						"container": "inputcontainer"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/linkedservice_Input')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataset_output')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "OutputLinkedService",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "result.txt",
						"folderPath": "output",
						"container": "inputcontainer"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/OutputLinkedService')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzurePostgreSql1')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzurePostgreSql",
				"typeProperties": {
					"connectionString": "[parameters('AzurePostgreSql1_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzurePostgreSql2')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"parameters": {
					"DbName1": {
						"type": "String"
					}
				},
				"annotations": [],
				"type": "AzurePostgreSql",
				"typeProperties": {
					"connectionString": "[parameters('AzurePostgreSql2_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzurePostgreSql3')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzurePostgreSql",
				"typeProperties": {
					"connectionString": "[parameters('AzurePostgreSql3_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/OutputLinkedService')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobStorage",
				"typeProperties": {
					"connectionString": "[parameters('OutputLinkedService_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/Pointsinput_linkedservice')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzurePostgreSql",
				"typeProperties": {
					"connectionString": "[parameters('Pointsinput_linkedservice_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/PostgreSql1_Rakesh_Fra_Admin')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "PostgreSql1_Rakesh_Fra_Admin",
				"annotations": [],
				"type": "PostgreSql",
				"typeProperties": {
					"connectionString": "[parameters('PostgreSql1_Rakesh_Fra_Admin_connectionString')]"
				},
				"connectVia": {
					"referenceName": "self-integrationRuntime2",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/integrationRuntimes/self-integrationRuntime2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/PostgreSql1_Rakesh_Ind_Postal')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "PostgreSql1_Rakesh_Ind_Postal",
				"annotations": [],
				"type": "PostgreSql",
				"typeProperties": {
					"connectionString": "[parameters('PostgreSql1_Rakesh_Ind_Postal_connectionString')]"
				},
				"connectVia": {
					"referenceName": "self-integrationRuntime2",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/integrationRuntimes/self-integrationRuntime2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/linkedservice_Input')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobStorage",
				"typeProperties": {
					"connectionString": "[parameters('linkedservice_Input_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pointoutput_linkedService')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzurePostgreSql",
				"typeProperties": {
					"connectionString": "[parameters('pointoutput_linkedService_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzureVMIntegrationRuntime')]",
			"type": "Microsoft.DataFactory/factories/integrationRuntimes",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "SelfHosted",
				"description": "Azure Windows VM in private tomtom network running integration runtime",
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/integrationRuntime1-Rakesh')]",
			"type": "Microsoft.DataFactory/factories/integrationRuntimes",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "SelfHosted",
				"description": "integrationRuntime1-Rakesh",
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/integrationRuntime1')]",
			"type": "Microsoft.DataFactory/factories/integrationRuntimes",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "Managed",
				"typeProperties": {
					"computeProperties": {
						"location": "AutoResolve",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 8,
							"timeToLive": 10,
							"cleanup": false
						}
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/self-integrationRuntime2')]",
			"type": "Microsoft.DataFactory/factories/integrationRuntimes",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "SelfHosted",
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/allpointsflow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "point"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointsink"
						}
					],
					"transformations": [
						{
							"name": "derivedColumns"
						}
					],
					"scriptLines": [
						"source(output(",
						"          pointid as long,",
						"          postalcode as string,",
						"          postalpointtype as string,",
						"          postalcodemain as string,",
						"          postalcodesub as string,",
						"          sourcetype as string,",
						"          postalpointgeometry as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT\\npop.osm_id pointId,\\npop.tags -> \\'postal_code\\' as postalCode,\\npop.tags ->\\'postal_point\\' as postalPointType,\\npop.tags ->\\'postal_code_main\\' as postalCodeMain,\\npop.tags ->\\'postal_code_sub\\' as postalCodeSub,\\n\\'TomTom\\' as sourceType,\\nST_AsText(pop.way) as postalPointGeometry\\nFROM planet_osm_point pop',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> point",
						"point derive(Uuid = uuid()) ~> derivedColumns",
						"derivedColumns sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          osm_id as long,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'point_vad',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update point_vad\\nset geometry= ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 0,",
						"     mapColumn(",
						"          id = Uuid,",
						"          osm_id = pointid,",
						"          geometrytext = postalpointgeometry",
						"     )) ~> pointsink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "Pointsinput_linkedservice",
								"type": "LinkedServiceReference"
							},
							"name": "pointsource"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "pointoutput_linkedService",
								"type": "LinkedServiceReference"
							},
							"name": "pointdestination"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          access as string,",
						"          {addr:housename} as string,",
						"          {addr:housenumber} as string,",
						"          {addr:interpolation} as string,",
						"          admin_level as string,",
						"          aerialway as string,",
						"          aeroway as string,",
						"          amenity as string,",
						"          area as string,",
						"          barrier as string,",
						"          bicycle as string,",
						"          brand as string,",
						"          bridge as string,",
						"          boundary as string,",
						"          building as string,",
						"          capital as string,",
						"          construction as string,",
						"          covered as string,",
						"          culvert as string,",
						"          cutting as string,",
						"          denomination as string,",
						"          disused as string,",
						"          ele as string,",
						"          embankment as string,",
						"          foot as string,",
						"          {generator:source} as string,",
						"          harbour as string,",
						"          highway as string,",
						"          historic as string,",
						"          horse as string,",
						"          intermittent as string,",
						"          junction as string,",
						"          landuse as string,",
						"          layer as string,",
						"          leisure as string,",
						"          lock as string,",
						"          man_made as string,",
						"          military as string,",
						"          motorcar as string,",
						"          name as string,",
						"          natural as string,",
						"          office as string,",
						"          oneway as string,",
						"          operator as string,",
						"          place as string,",
						"          population as string,",
						"          power as string,",
						"          power_source as string,",
						"          public_transport as string,",
						"          railway as string,",
						"          ref as string,",
						"          religion as string,",
						"          route as string,",
						"          service as string,",
						"          shop as string,",
						"          sport as string,",
						"          surface as string,",
						"          toll as string,",
						"          tourism as string,",
						"          {tower:type} as string,",
						"          tunnel as string,",
						"          water as string,",
						"          waterway as string,",
						"          wetland as string,",
						"          width as string,",
						"          wood as string,",
						"          z_order as integer,",
						"          tags as string,",
						"          way as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     format: 'table',",
						"     tableName: 'planet_osm_point',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED',",
						"     batchSize: 1000) ~> pointsource",
						"pointsource sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          osm_id as long,",
						"          access as string,",
						"          {addr:housename} as string,",
						"          {addr:housenumber} as string,",
						"          {addr:interpolation} as string,",
						"          admin_level as string,",
						"          aerialway as string,",
						"          aeroway as string,",
						"          amenity as string,",
						"          area as string,",
						"          barrier as string,",
						"          bicycle as string,",
						"          brand as string,",
						"          bridge as string,",
						"          boundary as string,",
						"          building as string,",
						"          capital as string,",
						"          construction as string,",
						"          covered as string,",
						"          culvert as string,",
						"          cutting as string,",
						"          denomination as string,",
						"          disused as string,",
						"          ele as string,",
						"          embankment as string,",
						"          foot as string,",
						"          {generator:source} as string,",
						"          harbour as string,",
						"          highway as string,",
						"          historic as string,",
						"          horse as string,",
						"          intermittent as string,",
						"          junction as string,",
						"          landuse as string,",
						"          layer as string,",
						"          leisure as string,",
						"          lock as string,",
						"          man_made as string,",
						"          military as string,",
						"          motorcar as string,",
						"          name as string,",
						"          natural as string,",
						"          office as string,",
						"          oneway as string,",
						"          operator as string,",
						"          place as string,",
						"          population as string,",
						"          power as string,",
						"          power_source as string,",
						"          public_transport as string,",
						"          railway as string,",
						"          ref as string,",
						"          religion as string,",
						"          route as string,",
						"          service as string,",
						"          shop as string,",
						"          sport as string,",
						"          surface as string,",
						"          toll as string,",
						"          tourism as string,",
						"          {tower:type} as string,",
						"          tunnel as string,",
						"          water as string,",
						"          waterway as string,",
						"          wetland as string,",
						"          width as string,",
						"          wood as string,",
						"          z_order as integer,",
						"          tags as string,",
						"          way as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'planet_osm_point_test',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     mapColumn(",
						"          each(match(true()))",
						"     )) ~> pointdestination"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/Pointsinput_linkedservice')]",
				"[concat(variables('factoryId'), '/linkedServices/pointoutput_linkedService')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "person1"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "person2"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "person12"
						}
					],
					"transformations": [
						{
							"name": "personsjoin"
						}
					],
					"scriptLines": [
						"source(output(",
						"          personid as integer,",
						"          lastname as string,",
						"          firstname as string,",
						"          address as string,",
						"          city as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     format: 'table',",
						"     tableName: 'persons1',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> person1",
						"source(output(",
						"          personid as integer,",
						"          lastname as string,",
						"          firstname as string,",
						"          address as string,",
						"          city as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'persons2',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> person2",
						"person1, person2 union(byName: true)~> personsjoin",
						"personsjoin sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'persons12',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> person12"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow3')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "points"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          capital as string,",
						"          name as string,",
						"          place as string,",
						"          way as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select osm_id, capital , \"name\" , place, ST_AsText(way) as way  from planet_osm_point pop',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> points",
						"points sink(allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     input(",
						"          osm_id as long,",
						"          capital as string,",
						"          name as string,",
						"          place as string,",
						"          way as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'planet_osm_point_test3',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update planet_osm_point_test3\\nset way3 = ST_GeomFromText(way)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow4')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "points"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointsink"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          pointid as long,",
						"          waytext as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT\\npop.osm_id pointId,\\nST_AsText(pop.way) as waytext\\nFROM planet_osm_rels por\\njoin planet_osm_point pop on cast(pop.osm_id as varchar) = substring(por.members[1],2)\\nwhere cast(por.members as varchar) like \\'%postalarea_center%\\' and por.id = 2000271000001143',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> points",
						"points derive(uuid = uuid()) ~> derivedColumn1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          osm_id as long,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'point_vad',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update point_vad\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          osm_id = pointid,",
						"          geometrytext = waytext,",
						"          id = uuid",
						"     )) ~> pointsink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow5')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postal"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointvad"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postalpointvadsink"
						}
					],
					"transformations": [
						{
							"name": "postalpointvad"
						},
						{
							"name": "finaldata"
						}
					],
					"scriptLines": [
						"source(output(",
						"          pointid as long,",
						"          postalcode as string,",
						"          postalpointtype as string,",
						"          postalcodemain as string,",
						"          postalcodesub as string,",
						"          sourcetype as string,",
						"          postalpointgeometry as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT\\npop.osm_id pointId,\\npop.tags -> \\'postal_code\\' as postalCode,\\npop.tags ->\\'postal_point\\' as postalPointType,\\npop.tags ->\\'postal_code_main\\' as postalCodeMain,\\npop.tags ->\\'postal_code_sub\\' as postalCodeSub,\\n\\'TomTom\\' as sourceType,\\nST_AsText(pop.way) as postalPointGeometry\\nFROM planet_osm_rels por\\njoin planet_osm_point pop on cast(pop.osm_id as varchar) = substring(por.members[1],2)\\nwhere cast(por.members as varchar) like \\'%postalarea_center%\\' and por.id = 2000271000001143',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> postal",
						"source(output(",
						"          id as string,",
						"          osm_id as long,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'point_vad',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointvad",
						"postal, pointvad join(pointid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> postalpointvad",
						"postalpointvad derive(postalpointuuid = uuid(),",
						"          createDate = currentTimestamp(),",
						"          modifiedDate = currentTimestamp()) ~> finaldata",
						"finaldata sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          point_id as string,",
						"          postal_point_osm_id as long,",
						"          postal_code as string,",
						"          postal_point_type as string,",
						"          postal_code_main as string,",
						"          postal_code_sub as string,",
						"          source_type as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          country as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'postal_point_vad',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update postal_point_vad\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          postal_code = postalcode,",
						"          postal_point_type = postalpointtype,",
						"          postal_code_main = postalcodemain,",
						"          postal_code_sub = postalcodesub,",
						"          source_type = sourcetype,",
						"          geometrytext = postalpointgeometry,",
						"          id = postalpointuuid,",
						"          created_date = createDate,",
						"          modified_date = modifiedDate,",
						"          point_id = id,",
						"          postal_point_osm_id = pointid",
						"     )) ~> postalpointvadsink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow6')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "test"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "test2"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          way_osm_id as long,",
						"          arr as string[]",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select way_osm_id, array_agg(node_uuid) as arr\\nfrom way_point_stagging ps\\ngroup by way_osm_id',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> source1",
						"source1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          osm_id as long,",
						"          points as string[]",
						"     ),",
						"     format: 'table',",
						"     tableName: 'test',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          osm_id = way_osm_id,",
						"          points = arr",
						"     )) ~> test",
						"source1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          osm_id as long,",
						"          points as string[]",
						"     ),",
						"     format: 'table',",
						"     tableName: 'test2',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          osm_id = way_osm_id,",
						"          points = arr",
						"     )) ~> test2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addressable_area_stagging')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Belgium_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "admincenter"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "label"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "releation"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "polygonstagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "addressableareastagging"
						}
					],
					"transformations": [
						{
							"name": "admincenterlabel"
						},
						{
							"name": "relpolygon"
						},
						{
							"name": "adminarea"
						},
						{
							"name": "derivedcol"
						}
					],
					"scriptLines": [
						"source(output(",
						"          areaosmid as long,",
						"          centeruuidid as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select\\npor.id as areaosmid,\\npop.id  as centeruuidid\\nfrom planet_osm_rels por\\nleft join area_center_stagging pop  on hstore(members) -> concat(\\'n\\',pop.osm_id)=\\'admin_centre\\'',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> admincenter",
						"source(output(",
						"          areaosmid as long,",
						"          labeluuidid as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select\\npor.id as areaosmid,\\npop.id as labeluuidid\\nfrom planet_osm_rels por\\nleft join area_center_stagging pop  on hstore(members) -> concat(\\'n\\',pop.osm_id)=\\'label\\'',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> label",
						"source(output(",
						"          osm_id as long,",
						"          sourcetype as string,",
						"          boundarytype as string,",
						"          boundary as string,",
						"          name as string,",
						"          admin_level as short,",
						"          country as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select por.id osm_id, \\nhstore(por.tags) -> \\'source\\' as sourceType,\\nhstore(por.tags) ->\\'type\\' as boundaryType,\\nhstore(por.tags) ->\\'boundary\\' as boundary,\\nhstore(por.tags) ->\\'name\\' as name,\\ncast(hstore(por.tags) ->\\'admin_level\\' as int2) as admin_level,\\n\\'BEL\\' as country\\nfrom planet_osm_rels por',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> releation",
						"source(output(",
						"          osm_id as long,",
						"          geometrytext as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select osm_id ,  st_astext(geometry) as geometrytext from polygon_stagging ps',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> polygonstagging",
						"admincenter, label join(admincenter@areaosmid == label@areaosmid,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> admincenterlabel",
						"releation, polygonstagging join(releation@osm_id == polygonstagging@osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> relpolygon",
						"admincenterlabel, relpolygon join(admincenter@areaosmid == releation@osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> adminarea",
						"adminarea derive(area_uuid = uuid(),",
						"          createdate = currentTimestamp(),",
						"          modifieddate = currentTimestamp(),",
						"          labeluuidid = iifNull(labeluuidid, '00000000-0000-0000-0000-000000000000'),",
						"          centeruuidid = iifNull(centeruuidid, '00000000-0000-0000-0000-000000000000')) ~> derivedcol",
						"derivedcol sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          osm_id as long,",
						"          name as string,",
						"          boundary as string,",
						"          admin_level as short,",
						"          admin_center_id as string,",
						"          area_label_id as string,",
						"          country as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          source_type as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'addressable_area_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update addressable_area_stagging \\nset geometry = ST_GeomFromText(geometrytext)\\n','update addressable_area_stagging \\nset admin_center_id  = null \\nwhere admin_center_id = \\'00000000-0000-0000-0000-000000000000\\'','update addressable_area_stagging \\nset area_label_id  = null \\nwhere area_label_id = \\'00000000-0000-0000-0000-000000000000\\''],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = area_uuid,",
						"          osm_id = admincenter@areaosmid,",
						"          name,",
						"          boundary,",
						"          admin_level,",
						"          admin_center_id = centeruuidid,",
						"          area_label_id = labeluuidid,",
						"          country,",
						"          source_type = sourcetype,",
						"          created_date = createdate,",
						"          modified_date = modifieddate,",
						"          geometrytext",
						"     )) ~> addressableareastagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addressable_area_stagging_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "France_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "admincenter"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "label"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "releation"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "polygonstagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "addressableareastagging"
						}
					],
					"transformations": [
						{
							"name": "admincenterlabel"
						},
						{
							"name": "relpolygon"
						},
						{
							"name": "adminarea"
						},
						{
							"name": "derivedcol"
						}
					],
					"scriptLines": [
						"source(output(",
						"          areaosmid as long,",
						"          centeruuidid as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select\\npor.id as areaosmid,\\npop.id  as centeruuidid\\nfrom planet_osm_rels por\\nleft join area_center_stagging pop  on hstore(members) -> concat(\\'n\\',pop.osm_id)=\\'admin_centre\\'',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> admincenter",
						"source(output(",
						"          areaosmid as long,",
						"          labeluuidid as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select\\npor.id as areaosmid,\\npop.id as labeluuidid\\nfrom planet_osm_rels por\\nleft join area_center_stagging pop  on hstore(members) -> concat(\\'n\\',pop.osm_id)=\\'label\\'',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> label",
						"source(output(",
						"          osm_id as long,",
						"          sourcetype as string,",
						"          boundarytype as string,",
						"          boundary as string,",
						"          name as string,",
						"          admin_level as short,",
						"          country as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select por.id osm_id, \\nhstore(por.tags) -> \\'source\\' as sourceType,\\nhstore(por.tags) ->\\'type\\' as boundaryType,\\nhstore(por.tags) ->\\'boundary\\' as boundary,\\nhstore(por.tags) ->\\'name\\' as name,\\ncast(hstore(por.tags) ->\\'admin_level\\' as int2) as admin_level,\\n\\'BEL\\' as country\\nfrom planet_osm_rels por',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> releation",
						"source(output(",
						"          osm_id as long,",
						"          geometrytext as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select osm_id ,  st_astext(geometry) as geometrytext from polygon_stagging ps',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> polygonstagging",
						"admincenter, label join(admincenter@areaosmid == label@areaosmid,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> admincenterlabel",
						"releation, polygonstagging join(releation@osm_id == polygonstagging@osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> relpolygon",
						"admincenterlabel, relpolygon join(admincenter@areaosmid == releation@osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> adminarea",
						"adminarea derive(area_uuid = uuid(),",
						"          createdate = currentTimestamp(),",
						"          modifieddate = currentTimestamp(),",
						"          labeluuidid = iifNull(labeluuidid, '00000000-0000-0000-0000-000000000000'),",
						"          centeruuidid = iifNull(centeruuidid, '00000000-0000-0000-0000-000000000000')) ~> derivedcol",
						"derivedcol sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          osm_id as long,",
						"          name as string,",
						"          boundary as string,",
						"          admin_level as short,",
						"          admin_center_id as string,",
						"          area_label_id as string,",
						"          country as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          source_type as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'addressable_area_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update addressable_area_stagging \\nset geometry = ST_GeomFromText(geometrytext)\\n','update addressable_area_stagging \\nset admin_center_id  = null \\nwhere admin_center_id = \\'00000000-0000-0000-0000-000000000000\\'','update addressable_area_stagging \\nset area_label_id  = null \\nwhere area_label_id = \\'00000000-0000-0000-0000-000000000000\\''],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = area_uuid,",
						"          osm_id = admincenter@areaosmid,",
						"          name,",
						"          boundary,",
						"          admin_level,",
						"          admin_center_id = centeruuidid,",
						"          area_label_id = labeluuidid,",
						"          country,",
						"          source_type = sourcetype,",
						"          created_date = createdate,",
						"          modified_date = modifieddate,",
						"          geometrytext",
						"     )) ~> addressableareastagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_admin_center_admin_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "OSM point > postal point",
				"folder": {
					"name": "Belgium_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "osmpoint"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "postalpointstagging"
						}
					],
					"transformations": [
						{
							"name": "joinpointpointstagging"
						},
						{
							"name": "addeduuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          name as string,",
						"          country as string,",
						"          place as string,",
						"          sourcetype as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select pop.osm_id, \\npop.\"name\" , \\'BEL\\' as country, pop.place , \\'TomTom\\' as sourceType, ST_AsText(pop.way) as geometry\\nFROM planet_osm_point pop',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmpoint",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'point_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"osmpoint, pointstagging join(osmpoint@osm_id == pointstagging@osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinpointpointstagging",
						"joinpointpointstagging derive(ac_uuid = uuid(),",
						"          createdate = currentTimestamp(),",
						"          modifydate = currentTimestamp()) ~> addeduuid",
						"addeduuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          osm_id as long,",
						"          name as string,",
						"          country as string,",
						"          type as string,",
						"          place as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          source_type as string,",
						"          point_id as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'area_center_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update area_center_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = ac_uuid,",
						"          osm_id = osmpoint@osm_id,",
						"          name,",
						"          country,",
						"          place,",
						"          source_type = sourcetype,",
						"          point_id = uu_id,",
						"          created_date = createdate,",
						"          modified_date = modifydate,",
						"          geometrytext = osmpoint@geometry",
						"     )) ~> postalpointstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_admin_center_admin_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "OSM point > postal point",
				"folder": {
					"name": "France_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "osmpoint"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "postalpointstagging"
						}
					],
					"transformations": [
						{
							"name": "joinpointpointstagging"
						},
						{
							"name": "addeduuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          name as string,",
						"          country as string,",
						"          place as string,",
						"          sourcetype as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select pop.osm_id, \\npop.\"name\" , \\'BEL\\' as country, pop.place , \\'TomTom\\' as sourceType, ST_AsText(pop.way) as geometry\\nFROM planet_osm_point pop',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmpoint",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'point_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"osmpoint, pointstagging join(osmpoint@osm_id == pointstagging@osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinpointpointstagging",
						"joinpointpointstagging derive(ac_uuid = uuid(),",
						"          createdate = currentTimestamp(),",
						"          modifydate = currentTimestamp()) ~> addeduuid",
						"addeduuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          osm_id as long,",
						"          name as string,",
						"          country as string,",
						"          type as string,",
						"          place as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          source_type as string,",
						"          point_id as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'area_center_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update area_center_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = ac_uuid,",
						"          osm_id = osmpoint@osm_id,",
						"          name,",
						"          country,",
						"          place,",
						"          source_type = sourcetype,",
						"          point_id = uu_id,",
						"          created_date = createdate,",
						"          modified_date = modifydate,",
						"          geometrytext = osmpoint@geometry",
						"     )) ~> postalpointstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_area_polygon_admin_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "osm polygon > postal polygon",
				"folder": {
					"name": "Belgium_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "osmpolygon"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "polygonstagging"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          geometrytext as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT ABS(osm_id) as osm_id, st_astext(ST_Multi(\\'GEOMETRYCOLLECTION(\\' || string_agg(ST_AsText(way), \\', \\' ORDER BY osm_id) || \\')\\')) as geometrytext from planet_osm_polygon GROUP BY osm_id',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmpolygon",
						"osmpolygon sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          osm_id as long,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'polygon_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update polygon_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          osm_id,",
						"          geometrytext",
						"     )) ~> polygonstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_area_polygon_admin_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "osm polygon > postal polygon",
				"folder": {
					"name": "France_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "osmpolygon"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "polygonstagging"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          geometrytext as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT ABS(osm_id) as osm_id, st_astext(ST_Multi(\\'GEOMETRYCOLLECTION(\\' || string_agg(ST_AsText(way), \\', \\' ORDER BY osm_id) || \\')\\')) as geometrytext from planet_osm_polygon GROUP BY osm_id',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmpolygon",
						"osmpolygon sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          osm_id as long,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'polygon_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update polygon_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          osm_id,",
						"          geometrytext",
						"     )) ~> polygonstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_area_stagging')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmarea"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "polygonstagging"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postalpointstaging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "areastagging"
						}
					],
					"transformations": [
						{
							"name": "areapolygonstagging"
						},
						{
							"name": "postalpointsaggingjoin"
						},
						{
							"name": "addiotnalcol"
						}
					],
					"scriptLines": [
						"source(output(",
						"          areaid as long,",
						"          sourcetype as string,",
						"          boundarytype as string,",
						"          postalboundary as string,",
						"          postalcode as string,",
						"          name as string,",
						"          country as string,",
						"          postalpointidosmid as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select por.id areaid, \\nhstore(por.tags) -> \\'source\\' as sourceType,\\nhstore(por.tags) ->\\'type\\' as boundaryType,\\nhstore(por.tags) ->\\'boundary\\' as postalBoundary,\\nhstore(por.tags) ->\\'postal_code\\' as postalCode,\\nhstore(por.tags) ->\\'name\\' as name,\\n\\'BEL\\' as country,\\ncast ( substring(por.members[1],2) as int8) as postalPointIdOsmId\\nfrom planet_osm_rels por',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> osmarea",
						"source(output(",
						"          osm_id as long,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'polygon_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> polygonstagging",
						"source(output(",
						"          id as string,",
						"          point_id as string,",
						"          postal_point_osm_id as long,",
						"          postal_code as string,",
						"          postal_point_type as string,",
						"          postal_code_main as string,",
						"          postal_code_sub as string,",
						"          source_type as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          country as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'postal_point_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> postalpointstaging",
						"osmarea, polygonstagging join(areaid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> areapolygonstagging",
						"areapolygonstagging, postalpointstaging join(postalpointidosmid == postal_point_osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> postalpointsaggingjoin",
						"postalpointsaggingjoin derive(uuid_portalarea = uuid(),",
						"          createdate = currentTimestamp(),",
						"          updatedate = currentTimestamp()) ~> addiotnalcol",
						"addiotnalcol sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          name as string,",
						"          postal_code as string,",
						"          postal_point_id as string,",
						"          source_type as string,",
						"          country as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string,",
						"          area_osm_id as long",
						"     ),",
						"     format: 'table',",
						"     tableName: 'postal_area_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update postal_area_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = uuid_portalarea,",
						"          postal_code = postalcode,",
						"          postal_point_id = id,",
						"          name,",
						"          source_type = sourcetype,",
						"          country = osmarea@country,",
						"          created_date = createdate,",
						"          modified_date,",
						"          geometrytext = polygonstagging@geometrytext,",
						"          area_osm_id = areaid",
						"     )) ~> areastagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_line_admin_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "agg point > line \n(string[] uuid> uuid[] uuid)",
				"folder": {
					"name": "Belgium_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "linepointagg"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "lines"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "aggtestfinal"
						}
					],
					"transformations": [
						{
							"name": "wayjoin"
						},
						{
							"name": "wayuuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'line_point_agg',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> linepointagg",
						"source(output(",
						"          osm_id as long,",
						"          waygeomtext as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT osm_id, st_astext(st_linemerge((st_collectionextract(\\'GEOMETRYCOLLECTION(\\' || string_agg(ST_AsText(way), \\', \\' ORDER BY osm_id) || \\')\\') ))) as waygeomtext\\nfrom planet_osm_line\\nwhere osm_id > 0\\nGROUP BY osm_id',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> lines",
						"linepointagg, lines join(way_osm_id == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> wayjoin",
						"wayjoin derive(way_uuid = uuid()) ~> wayuuid",
						"wayuuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string,",
						"          geometrytext as string,",
						"          geometry as string,",
						"          pointsuuidarray as string[],",
						"          ways_uuid as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update line_stagging set geometry = ST_GeomFromText(geometrytext)\\n','update line_stagging set pointsuuidarray = cast(points as uuid[])'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          way_osm_id,",
						"          points,",
						"          attributes,",
						"          geometrytext = waygeomtext,",
						"          ways_uuid = way_uuid",
						"     )) ~> aggtestfinal"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_line_admin_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "agg point > line \n(string[] uuid> uuid[] uuid)",
				"folder": {
					"name": "France_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "linepointagg"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "lines"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "aggtestfinal"
						}
					],
					"transformations": [
						{
							"name": "wayjoin"
						},
						{
							"name": "wayuuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'line_point_agg',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> linepointagg",
						"source(output(",
						"          osm_id as long,",
						"          waygeomtext as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT osm_id, st_astext(st_linemerge((st_collectionextract(\\'GEOMETRYCOLLECTION(\\' || string_agg(ST_AsText(way), \\', \\' ORDER BY osm_id) || \\')\\') ))) as waygeomtext\\nfrom planet_osm_line\\nwhere osm_id > 0\\nGROUP BY osm_id',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> lines",
						"linepointagg, lines join(way_osm_id == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> wayjoin",
						"wayjoin derive(way_uuid = uuid()) ~> wayuuid",
						"wayuuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string,",
						"          geometrytext as string,",
						"          geometry as string,",
						"          pointsuuidarray as string[],",
						"          ways_uuid as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update line_stagging set geometry = ST_GeomFromText(geometrytext)\\n','update line_stagging set pointsuuidarray = cast(points as uuid[])'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          way_osm_id,",
						"          points,",
						"          attributes,",
						"          geometrytext = waygeomtext,",
						"          ways_uuid = way_uuid",
						"     )) ~> aggtestfinal"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_line_postal_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "agg point > line \n(string[] uuid> uuid[] uuid)",
				"folder": {
					"name": "Belgium_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "linepointagg"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "points"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "aggtestfinal"
						}
					],
					"transformations": [
						{
							"name": "wayjoin"
						},
						{
							"name": "wayuuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'line_point_agg',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> linepointagg",
						"source(output(",
						"          osm_id as long,",
						"          waygeomtext as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select osm_id, st_astext(way) as waygeomtext  from planet_osm_line pol\\nwhere osm_id > 0\\n',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> points",
						"linepointagg, points join(way_osm_id == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> wayjoin",
						"wayjoin derive(way_uuid = uuid()) ~> wayuuid",
						"wayuuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string,",
						"          geometrytext as string,",
						"          geometry as string,",
						"          pointsuuidarray as string[],",
						"          ways_uuid as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update line_stagging set geometry = ST_GeomFromText(geometrytext)\\n','update line_stagging set pointsuuidarray = cast(points as uuid[])'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          way_osm_id,",
						"          points,",
						"          attributes,",
						"          geometrytext = waygeomtext,",
						"          ways_uuid = way_uuid",
						"     )) ~> aggtestfinal"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_line_postal_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "agg point > line \n(string[] uuid> uuid[] uuid)",
				"folder": {
					"name": "India_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "linepointagg"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "lines"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "aggtestfinal"
						}
					],
					"transformations": [
						{
							"name": "wayjoin"
						},
						{
							"name": "wayuuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'line_point_agg',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> linepointagg",
						"source(output(",
						"          osm_id as long,",
						"          waygeomtext as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT osm_id, st_astext(st_linemerge((st_collectionextract(\\'GEOMETRYCOLLECTION(\\' || string_agg(ST_AsText(way), \\', \\' ORDER BY osm_id) || \\')\\') ))) as waygeomtext\\nfrom planet_osm_line\\nwhere osm_id > 0\\nGROUP BY osm_id',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> lines",
						"linepointagg, lines join(way_osm_id == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> wayjoin",
						"wayjoin derive(way_uuid = uuid()) ~> wayuuid",
						"wayuuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string,",
						"          geometrytext as string,",
						"          geometry as string,",
						"          pointsuuidarray as string[],",
						"          ways_uuid as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update line_stagging set geometry = ST_GeomFromText(geometrytext)\\n','update line_stagging set pointsuuidarray = cast(points as uuid[])'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          way_osm_id,",
						"          points,",
						"          attributes,",
						"          geometrytext = waygeomtext,",
						"          ways_uuid = way_uuid",
						"     )) ~> aggtestfinal"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_linegeom')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "aggtest"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "points"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "aggtestfinal"
						}
					],
					"transformations": [
						{
							"name": "wayjoin"
						},
						{
							"name": "wayuuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'agg_test',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> aggtest",
						"source(output(",
						"          osm_id as long,",
						"          waygeomtext as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select osm_id, st_astext(way) as waygeomtext  from planet_osm_line pol\\nwhere osm_id > 0\\n',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> points",
						"aggtest, points join(way_osm_id == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> wayjoin",
						"wayjoin derive(way_uuid = uuid()) ~> wayuuid",
						"wayuuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string,",
						"          geometrytext as string,",
						"          geometry as string,",
						"          pointsuuidarray as string[],",
						"          ways_uuid as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'agg_test_final',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update agg_test_final set geometry = ST_GeomFromText(geometrytext)\\n','update agg_test_final set pointsuuidarray = cast(points as uuid[])'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          way_osm_id,",
						"          points,",
						"          attributes,",
						"          geometrytext = waygeomtext,",
						"          ways_uuid = way_uuid",
						"     )) ~> aggtestfinal"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_lines_area')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "rels"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postalareastagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql2",
								"type": "LinkedServiceReference"
							},
							"name": "lineareastagging"
						}
					],
					"transformations": [
						{
							"name": "areajoin"
						},
						{
							"name": "derivedcols"
						}
					],
					"scriptLines": [
						"source(output(",
						"          rel_id as long,",
						"          ways_uuid as string,",
						"          membervalue as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select por.id as rel_id, pow.ways_uuid, \\nhstore(por.members) -> concat(\\'w\\',cast(pow.way_osm_id as text)) as membervalue\\nfrom\\nplanet_osm_rels por\\njoin line_stagging pow on concat(\\'w\\',cast(pow.way_osm_id as text))  = ANY(por.members)\\n',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> rels",
						"source(output(",
						"          areauuid as string,",
						"          area_osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select id as areauuid, area_osm_id from postal_area_stagging',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> postalareastagging",
						"rels, postalareastagging join(rel_id == area_osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> areajoin",
						"areajoin derive(id = uuid()) ~> derivedcols",
						"derivedcols sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          area_id as string,",
						"          line_id as string,",
						"          member_role as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_area_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id,",
						"          line_id = ways_uuid,",
						"          area_id = areauuid,",
						"          member_role = membervalue",
						"     )) ~> lineareastagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]",
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_lines_area_admin_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Belgium_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "rels"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "addressableareastagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "lineareastagging"
						}
					],
					"transformations": [
						{
							"name": "areajoin"
						},
						{
							"name": "derivedcols"
						}
					],
					"scriptLines": [
						"source(output(",
						"          rel_id as long,",
						"          ways_uuid as string,",
						"          membervalue as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select por.id as rel_id, pow.ways_uuid, \\nhstore(por.members) -> concat(\\'w\\',cast(pow.way_osm_id as text)) as membervalue\\nfrom planet_osm_rels por\\njoin line_stagging pow on concat(\\'w\\',cast(pow.way_osm_id as text))  = ANY(por.members)',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> rels",
						"source(output(",
						"          areauuid as string,",
						"          area_osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select id as areauuid, osm_id as area_osm_id from addressable_area_stagging',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> addressableareastagging",
						"rels, addressableareastagging join(rel_id == area_osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> areajoin",
						"areajoin derive(id = uuid()) ~> derivedcols",
						"derivedcols sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          area_id as string,",
						"          line_id as string,",
						"          member_role as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_area_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id,",
						"          line_id = ways_uuid,",
						"          area_id = areauuid,",
						"          member_role = membervalue",
						"     )) ~> lineareastagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_lines_area_admin_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "France_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "rels"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "addressableareastagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "lineareastagging"
						}
					],
					"transformations": [
						{
							"name": "areajoin"
						},
						{
							"name": "derivedcols"
						}
					],
					"scriptLines": [
						"source(output(",
						"          rel_id as long,",
						"          ways_uuid as string,",
						"          membervalue as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select por.id as rel_id, pow.ways_uuid, \\nhstore(por.members) -> concat(\\'w\\',cast(pow.way_osm_id as text)) as membervalue\\nfrom planet_osm_rels por\\njoin line_stagging pow on concat(\\'w\\',cast(pow.way_osm_id as text))  = ANY(por.members)',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> rels",
						"source(output(",
						"          areauuid as string,",
						"          area_osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select id as areauuid, osm_id as area_osm_id from addressable_area_stagging',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> addressableareastagging",
						"rels, addressableareastagging join(rel_id == area_osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> areajoin",
						"areajoin derive(id = uuid()) ~> derivedcols",
						"derivedcols sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          area_id as string,",
						"          line_id as string,",
						"          member_role as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_area_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id,",
						"          line_id = ways_uuid,",
						"          area_id = areauuid,",
						"          member_role = membervalue",
						"     )) ~> lineareastagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_lines_area_postal_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Belgium_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "rels"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postalareastagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "lineareastagging"
						}
					],
					"transformations": [
						{
							"name": "areajoin"
						},
						{
							"name": "derivedcols"
						}
					],
					"scriptLines": [
						"source(output(",
						"          rel_id as long,",
						"          ways_uuid as string,",
						"          membervalue as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select por.id as rel_id, pow.ways_uuid, \\nhstore(por.members) -> concat(\\'w\\',cast(pow.way_osm_id as text)) as membervalue\\nfrom\\nplanet_osm_rels por\\njoin line_stagging pow on concat(\\'w\\',cast(pow.way_osm_id as text))  = ANY(por.members)\\n',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> rels",
						"source(output(",
						"          areauuid as string,",
						"          area_osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select id as areauuid, area_osm_id from postal_area_stagging',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> postalareastagging",
						"rels, postalareastagging join(rel_id == area_osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> areajoin",
						"areajoin derive(id = uuid()) ~> derivedcols",
						"derivedcols sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          area_id as string,",
						"          line_id as string,",
						"          member_role as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_area_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id,",
						"          line_id = ways_uuid,",
						"          area_id = areauuid,",
						"          member_role = membervalue",
						"     )) ~> lineareastagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_lines_area_postal_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "India_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "rels"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postalareastagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "lineareastagging"
						}
					],
					"transformations": [
						{
							"name": "areajoin"
						},
						{
							"name": "derivedcols"
						}
					],
					"scriptLines": [
						"source(output(",
						"          rel_id as long,",
						"          ways_uuid as string,",
						"          membervalue as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select por.id as rel_id, pow.ways_uuid, \\nhstore(por.members) -> concat(\\'w\\',cast(pow.way_osm_id as text)) as membervalue\\nfrom\\nplanet_osm_rels por\\njoin line_stagging pow on concat(\\'w\\',cast(pow.way_osm_id as text))  = ANY(por.members)\\n',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> rels",
						"source(output(",
						"          areauuid as string,",
						"          area_osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select id as areauuid, area_osm_id from postal_area_stagging',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> postalareastagging",
						"rels, postalareastagging join(rel_id == area_osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> areajoin",
						"areajoin derive(id = uuid()) ~> derivedcols",
						"derivedcols sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          area_id as string,",
						"          line_id as string,",
						"          member_role as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_area_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id,",
						"          line_id = ways_uuid,",
						"          area_id = areauuid,",
						"          member_role = membervalue",
						"     )) ~> lineareastagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_point_admin_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Populate Point staging - OSM Node data  > Point staging",
				"folder": {
					"name": "Belgium_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "osmnode"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"transformations": [
						{
							"name": "osmnodewithuuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          gemotext as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select id, lat, lon , ST_AsText(ST_MakePoint(cast(lon as float)/10000000,cast(lat as float)/10000000)) as gemotext from  planet_osm_nodes',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmnode",
						"osmnode derive(uuid = uuid()) ~> osmnodewithuuid",
						"osmnodewithuuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          uu_id as string,",
						"          osm_id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'point_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update point_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     mapColumn(",
						"          osm_id = id,",
						"          uu_id = uuid,",
						"          lat,",
						"          lon,",
						"          geometrytext = gemotext",
						"     )) ~> pointstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_point_admin_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Populate Point staging - OSM Node data  > Point staging",
				"folder": {
					"name": "France_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "osmnode"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"transformations": [
						{
							"name": "osmnodewithuuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          gemotext as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select id, lat, lon , ST_AsText(ST_MakePoint(cast(lon as float)/10000000,cast(lat as float)/10000000)) as gemotext from  planet_osm_nodes',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmnode",
						"osmnode derive(uuid = uuid()) ~> osmnodewithuuid",
						"osmnodewithuuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          uu_id as string,",
						"          osm_id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'point_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update point_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     mapColumn(",
						"          osm_id = id,",
						"          uu_id = uuid,",
						"          lat,",
						"          lon,",
						"          geometrytext = gemotext",
						"     )) ~> pointstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_point_postal_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Populate Point staging - OSM Node data  > Point staging",
				"folder": {
					"name": "Belgium_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmnode"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"transformations": [
						{
							"name": "osmnodewithuuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          gemotext as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select id, lat, lon , ST_AsText(ST_MakePoint(cast(lon as float)/10000000,cast(lat as float)/10000000)) as gemotext \\nfrom  planet_osm_nodes',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmnode",
						"osmnode derive(uuid = uuid()) ~> osmnodewithuuid",
						"osmnodewithuuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          uu_id as string,",
						"          osm_id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'point_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update point_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          osm_id = id,",
						"          lat,",
						"          lon,",
						"          geometrytext = gemotext,",
						"          uu_id = uuid",
						"     )) ~> pointstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_point_postal_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Populate Point staging - OSM Node data  > Point staging",
				"folder": {
					"name": "India_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmnode"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"transformations": [
						{
							"name": "osmnodewithuuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          gemotext as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select id, lat, lon , ST_AsText(ST_MakePoint(cast(lon as float)/10000000,cast(lat as float)/10000000)) as gemotext \\nfrom  planet_osm_nodes',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmnode",
						"osmnode derive(uuid = uuid()) ~> osmnodewithuuid",
						"osmnodewithuuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          uu_id as string,",
						"          osm_id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'point_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update point_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          osm_id = id,",
						"          lat,",
						"          lon,",
						"          geometrytext = gemotext,",
						"          uu_id = uuid",
						"     )) ~> pointstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_point_stagging')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmnode"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"transformations": [
						{
							"name": "osmnodewithuuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          gemotext as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select id, lat, lon , ST_AsText(ST_MakePoint(cast(lon as float)/10000000,cast(lat as float)/10000000)) as gemotext \\nfrom  planet_osm_nodes',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmnode",
						"osmnode derive(uuid = uuid()) ~> osmnodewithuuid",
						"osmnodewithuuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          uu_id as string,",
						"          osm_id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'point_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update point_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          osm_id = id,",
						"          lat,",
						"          lon,",
						"          geometrytext = gemotext,",
						"          uu_id = uuid",
						"     )) ~> pointstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_point_vad')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "poindvad"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'point_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"pointstagging sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          osm_id as long,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'point_vad',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update point_vad\\nset geometry = ST_GeomFromText(geometrytext)\\n'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = uu_id,",
						"          osm_id,",
						"          geometrytext",
						"     )) ~> poindvad"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_postal_area_admin_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "OSM releation > Polygon > Postal Area",
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmarea"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "polygonstagging"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postalpointstaging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "areastagging"
						}
					],
					"transformations": [
						{
							"name": "areapolygonstagging"
						},
						{
							"name": "postalpointsaggingjoin"
						},
						{
							"name": "addiotnalcol"
						}
					],
					"scriptLines": [
						"source(output(",
						"          areaid as long,",
						"          sourcetype as string,",
						"          boundarytype as string,",
						"          postalboundary as string,",
						"          postalcode as string,",
						"          name as string,",
						"          country as string,",
						"          postalpointidosmid as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select por.id areaid, \\nhstore(por.tags) -> \\'source\\' as sourceType,\\nhstore(por.tags) ->\\'type\\' as boundaryType,\\nhstore(por.tags) ->\\'boundary\\' as postalBoundary,\\nhstore(por.tags) ->\\'postal_code\\' as postalCode,\\nhstore(por.tags) ->\\'name\\' as name,\\n\\'BEL\\' as country,\\ncast ( substring(por.members[1],2) as int8) as postalPointIdOsmId\\nfrom planet_osm_rels por',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> osmarea",
						"source(output(",
						"          osm_id as long,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'polygon_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> polygonstagging",
						"source(output(",
						"          id as string,",
						"          point_id as string,",
						"          postal_point_osm_id as long,",
						"          postal_code as string,",
						"          postal_point_type as string,",
						"          postal_code_main as string,",
						"          postal_code_sub as string,",
						"          source_type as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          country as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'postal_point_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> postalpointstaging",
						"osmarea, polygonstagging join(areaid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> areapolygonstagging",
						"areapolygonstagging, postalpointstaging join(postalpointidosmid == postal_point_osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> postalpointsaggingjoin",
						"postalpointsaggingjoin derive(uuid_portalarea = uuid(),",
						"          createdate = currentTimestamp(),",
						"          updatedate = currentTimestamp()) ~> addiotnalcol",
						"addiotnalcol sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          name as string,",
						"          postal_code as string,",
						"          postal_point_id as string,",
						"          source_type as string,",
						"          country as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string,",
						"          area_osm_id as long",
						"     ),",
						"     format: 'table',",
						"     tableName: 'postal_area_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update postal_area_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = uuid_portalarea,",
						"          postal_code = postalcode,",
						"          postal_point_id = id,",
						"          name,",
						"          source_type = sourcetype,",
						"          country = osmarea@country,",
						"          created_date = createdate,",
						"          modified_date,",
						"          geometrytext = polygonstagging@geometrytext,",
						"          area_osm_id = areaid",
						"     )) ~> areastagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_postal_area_postal_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "OSM releation > Polygon > Postal Area",
				"folder": {
					"name": "Belgium_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmarea"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "polygonstagging"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postalpointstaging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "areastagging"
						}
					],
					"transformations": [
						{
							"name": "areapolygonstagging"
						},
						{
							"name": "postalpointsaggingjoin"
						},
						{
							"name": "addiotnalcol"
						}
					],
					"scriptLines": [
						"source(output(",
						"          areaid as long,",
						"          sourcetype as string,",
						"          boundarytype as string,",
						"          postalboundary as string,",
						"          postalcode as string,",
						"          name as string,",
						"          country as string,",
						"          postalpointidosmid as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select por.id areaid, \\nhstore(por.tags) -> \\'source\\' as sourceType,\\nhstore(por.tags) ->\\'type\\' as boundaryType,\\nhstore(por.tags) ->\\'boundary\\' as postalBoundary,\\nhstore(por.tags) ->\\'postal_code\\' as postalCode,\\nhstore(por.tags) ->\\'name\\' as name,\\n\\'BEL\\' as country,\\ncast ( substring(por.members[1],2) as int8) as postalPointIdOsmId\\nfrom planet_osm_rels por',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> osmarea",
						"source(output(",
						"          osm_id as long,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'polygon_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> polygonstagging",
						"source(output(",
						"          id as string,",
						"          point_id as string,",
						"          postal_point_osm_id as long,",
						"          postal_code as string,",
						"          postal_point_type as string,",
						"          postal_code_main as string,",
						"          postal_code_sub as string,",
						"          source_type as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          country as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'postal_point_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> postalpointstaging",
						"osmarea, polygonstagging join(areaid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> areapolygonstagging",
						"areapolygonstagging, postalpointstaging join(postalpointidosmid == postal_point_osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> postalpointsaggingjoin",
						"postalpointsaggingjoin derive(uuid_portalarea = uuid(),",
						"          createdate = currentTimestamp(),",
						"          updatedate = currentTimestamp()) ~> addiotnalcol",
						"addiotnalcol sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          name as string,",
						"          postal_code as string,",
						"          postal_point_id as string,",
						"          source_type as string,",
						"          country as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string,",
						"          area_osm_id as long",
						"     ),",
						"     format: 'table',",
						"     tableName: 'postal_area_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update postal_area_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = uuid_portalarea,",
						"          postal_code = postalcode,",
						"          postal_point_id = id,",
						"          name,",
						"          source_type = sourcetype,",
						"          country = osmarea@country,",
						"          created_date = createdate,",
						"          modified_date,",
						"          geometrytext = polygonstagging@geometrytext,",
						"          area_osm_id = areaid",
						"     )) ~> areastagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_postal_area_postal_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "OSM releation > Polygon > Postal Area",
				"folder": {
					"name": "India_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmarea"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "polygonstagging"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postalpointstaging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "areastagging"
						}
					],
					"transformations": [
						{
							"name": "areapolygonstagging"
						},
						{
							"name": "postalpointsaggingjoin"
						},
						{
							"name": "addiotnalcol"
						}
					],
					"scriptLines": [
						"source(output(",
						"          areaid as long,",
						"          sourcetype as string,",
						"          boundarytype as string,",
						"          postalboundary as string,",
						"          postalcode as string,",
						"          name as string,",
						"          country as string,",
						"          postalpointidosmid as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select por.id areaid, \\nhstore(por.tags) -> \\'source\\' as sourceType,\\nhstore(por.tags) ->\\'type\\' as boundaryType,\\nhstore(por.tags) ->\\'boundary\\' as postalBoundary,\\nhstore(por.tags) ->\\'postal_code\\' as postalCode,\\nhstore(por.tags) ->\\'name\\' as name,\\n\\'BEL\\' as country,\\ncast ( substring(por.members[1],2) as int8) as postalPointIdOsmId\\nfrom planet_osm_rels por',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> osmarea",
						"source(output(",
						"          osm_id as long,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'polygon_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> polygonstagging",
						"source(output(",
						"          id as string,",
						"          point_id as string,",
						"          postal_point_osm_id as long,",
						"          postal_code as string,",
						"          postal_point_type as string,",
						"          postal_code_main as string,",
						"          postal_code_sub as string,",
						"          source_type as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          country as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'postal_point_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> postalpointstaging",
						"osmarea, polygonstagging join(areaid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> areapolygonstagging",
						"areapolygonstagging, postalpointstaging join(postalpointidosmid == postal_point_osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> postalpointsaggingjoin",
						"postalpointsaggingjoin derive(uuid_portalarea = uuid(),",
						"          createdate = currentTimestamp(),",
						"          updatedate = currentTimestamp()) ~> addiotnalcol",
						"addiotnalcol sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          name as string,",
						"          postal_code as string,",
						"          postal_point_id as string,",
						"          source_type as string,",
						"          country as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string,",
						"          area_osm_id as long",
						"     ),",
						"     format: 'table',",
						"     tableName: 'postal_area_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update postal_area_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = uuid_portalarea,",
						"          postal_code = postalcode,",
						"          postal_point_id = id,",
						"          name,",
						"          source_type = sourcetype,",
						"          country = osmarea@country,",
						"          created_date = createdate,",
						"          modified_date,",
						"          geometrytext = polygonstagging@geometrytext,",
						"          area_osm_id = areaid",
						"     )) ~> areastagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_postal_point_postal_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "OSM point > postal point",
				"folder": {
					"name": "Belgium_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmpoint"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postalpointstagging"
						}
					],
					"transformations": [
						{
							"name": "joinpointpointstagging"
						},
						{
							"name": "addeduuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          postalcode as string,",
						"          postalpointtype as string,",
						"          postalcodemain as string,",
						"          postalcodesub as string,",
						"          sourcetype as string,",
						"          postalpointgeometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT\\npop.osm_id,\\npop.tags -> \\'postal_code\\' as postalCode,\\npop.tags ->\\'postal_point\\' as postalPointType,\\npop.tags ->\\'postal_code_main\\' as postalCodeMain,\\npop.tags ->\\'postal_code_sub\\' as postalCodeSub,\\n\\'TomTom\\' as sourceType,\\nST_AsText(pop.way) as postalPointGeometry\\nFROM planet_osm_point pop',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmpoint",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'point_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"osmpoint, pointstagging join(osmpoint@osm_id == pointstagging@osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinpointpointstagging",
						"joinpointpointstagging derive(pp_uuid = uuid(),",
						"          createdate = currentTimestamp(),",
						"          modifydate = currentTimestamp()) ~> addeduuid",
						"addeduuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          point_id as string,",
						"          postal_point_osm_id as long,",
						"          postal_code as string,",
						"          postal_point_type as string,",
						"          postal_code_main as string,",
						"          postal_code_sub as string,",
						"          source_type as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          country as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'postal_point_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update postal_point_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = pp_uuid,",
						"          point_id = uu_id,",
						"          postal_point_osm_id = osmpoint@osm_id,",
						"          postal_code = postalcode,",
						"          postal_point_type = postalpointtype,",
						"          postal_code_main = postalcodemain,",
						"          source_type = sourcetype,",
						"          geometrytext = postalpointgeometry,",
						"          created_date = createdate,",
						"          modified_date = modifydate",
						"     )) ~> postalpointstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_postal_point_postal_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "OSM point > postal point",
				"folder": {
					"name": "India_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmpoint"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postalpointstagging"
						}
					],
					"transformations": [
						{
							"name": "joinpointpointstagging"
						},
						{
							"name": "addeduuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          postalcode as string,",
						"          postalpointtype as string,",
						"          postalcodemain as string,",
						"          postalcodesub as string,",
						"          sourcetype as string,",
						"          postalpointgeometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT\\npop.osm_id,\\npop.tags -> \\'postal_code\\' as postalCode,\\npop.tags ->\\'postal_point\\' as postalPointType,\\npop.tags ->\\'postal_code_main\\' as postalCodeMain,\\npop.tags ->\\'postal_code_sub\\' as postalCodeSub,\\n\\'TomTom\\' as sourceType,\\nST_AsText(pop.way) as postalPointGeometry\\nFROM planet_osm_point pop',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmpoint",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'point_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"osmpoint, pointstagging join(osmpoint@osm_id == pointstagging@osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinpointpointstagging",
						"joinpointpointstagging derive(pp_uuid = uuid(),",
						"          createdate = currentTimestamp(),",
						"          modifydate = currentTimestamp()) ~> addeduuid",
						"addeduuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          point_id as string,",
						"          postal_point_osm_id as long,",
						"          postal_code as string,",
						"          postal_point_type as string,",
						"          postal_code_main as string,",
						"          postal_code_sub as string,",
						"          source_type as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          country as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'postal_point_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update postal_point_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = pp_uuid,",
						"          point_id = uu_id,",
						"          postal_point_osm_id = osmpoint@osm_id,",
						"          postal_code = postalcode,",
						"          postal_point_type = postalpointtype,",
						"          postal_code_main = postalcodemain,",
						"          source_type = sourcetype,",
						"          geometrytext = postalpointgeometry,",
						"          created_date = createdate,",
						"          modified_date = modifydate",
						"     )) ~> postalpointstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_postalarea_polygon_postal_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "osm polygon > postal polygon",
				"folder": {
					"name": "Belgium_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmpolygon"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "polygonstagging"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          geometrytext as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT ABS(osm_id) as osm_id, st_astext(ST_Multi(\\'GEOMETRYCOLLECTION(\\' || string_agg(ST_AsText(way), \\', \\' ORDER BY osm_id) || \\')\\')) as geometrytext\\nfrom planet_osm_polygon\\nGROUP BY osm_id',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmpolygon",
						"osmpolygon sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          osm_id as long,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'polygon_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update polygon_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          osm_id,",
						"          geometrytext",
						"     )) ~> polygonstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_postalarea_polygon_postal_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "osm polygon > postal polygon",
				"folder": {
					"name": "India_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmpolygon"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "polygonstagging"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          geometrytext as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT ABS(osm_id) as osm_id, st_astext(ST_Multi(\\'GEOMETRYCOLLECTION(\\' || string_agg(ST_AsText(way), \\', \\' ORDER BY osm_id) || \\')\\')) as geometrytext\\nfrom planet_osm_polygon\\nGROUP BY osm_id',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmpolygon",
						"osmpolygon sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          osm_id as long,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'polygon_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update polygon_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          osm_id,",
						"          geometrytext",
						"     )) ~> polygonstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_postalarea_polygon_stagging')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmpolygon"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "polygonstagging"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          geometrytext as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT ABS(osm_id) as osm_id, st_astext(ST_Multi(\\'GEOMETRYCOLLECTION(\\' || string_agg(ST_AsText(way), \\', \\' ORDER BY osm_id) || \\')\\')) as geometrytext\\nfrom planet_osm_polygon\\nGROUP BY osm_id',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmpolygon",
						"osmpolygon sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          osm_id as long,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'polygon_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update polygon_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          osm_id,",
						"          geometrytext",
						"     )) ~> polygonstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_postalpoint_stagging')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "osmpoint"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "postalpointstagging"
						}
					],
					"transformations": [
						{
							"name": "joinpointpointstagging"
						},
						{
							"name": "addeduuid"
						}
					],
					"scriptLines": [
						"source(output(",
						"          osm_id as long,",
						"          postalcode as string,",
						"          postalpointtype as string,",
						"          postalcodemain as string,",
						"          postalcodesub as string,",
						"          sourcetype as string,",
						"          postalpointgeometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'SELECT\\npop.osm_id,\\npop.tags -> \\'postal_code\\' as postalCode,\\npop.tags ->\\'postal_point\\' as postalPointType,\\npop.tags ->\\'postal_code_main\\' as postalCodeMain,\\npop.tags ->\\'postal_code_sub\\' as postalCodeSub,\\n\\'TomTom\\' as sourceType,\\nST_AsText(pop.way) as postalPointGeometry\\nFROM planet_osm_point pop',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> osmpoint",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long,",
						"          lat as integer,",
						"          lon as integer,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     tableName: 'point_stagging',",
						"     schemaName: 'public',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"osmpoint, pointstagging join(osmpoint@osm_id == pointstagging@osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinpointpointstagging",
						"joinpointpointstagging derive(pp_uuid = uuid(),",
						"          createdate = currentTimestamp(),",
						"          modifydate = currentTimestamp()) ~> addeduuid",
						"addeduuid sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          point_id as string,",
						"          postal_point_osm_id as long,",
						"          postal_code as string,",
						"          postal_point_type as string,",
						"          postal_code_main as string,",
						"          postal_code_sub as string,",
						"          source_type as string,",
						"          qa_status as string,",
						"          violations as string,",
						"          country as string,",
						"          attributes as string,",
						"          created_date as timestamp,",
						"          modified_date as timestamp,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'postal_point_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update postal_point_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = pp_uuid,",
						"          point_id = uu_id,",
						"          postal_point_osm_id = osmpoint@osm_id,",
						"          postal_code = postalcode,",
						"          postal_point_type = postalpointtype,",
						"          postal_code_main = postalcodemain,",
						"          source_type = sourcetype,",
						"          geometrytext = postalpointgeometry,",
						"          created_date = createdate,",
						"          modified_date = modifydate",
						"     )) ~> postalpointstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_test_uuidarray')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "ways"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "lines"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "aggtest"
						}
					],
					"transformations": [
						{
							"name": "waypointsstagging"
						},
						{
							"name": "aggregate1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          nodeid as long,",
						"          wayid as long,",
						"          tags as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select  unnest(w.nodes) as nodeid, w.id as wayId, cast(cast(w.tags as hstore) as json) as tags\\nfrom planet_osm_ways w',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> ways",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select uu_id , osm_id  from point_stagging ps ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"source(output(",
						"          osm_id as long,",
						"          way as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select abs(osm_id) as osm_id , way  from planet_osm_line pol ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> lines",
						"ways, pointstagging join(nodeid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> waypointsstagging",
						"waypointsstagging aggregate(groupBy(wayid,",
						"          tags),",
						"     nodesArray = collect(uu_id)) ~> aggregate1",
						"aggregate1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'agg_test',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          way_osm_id = wayid,",
						"          attributes = tags,",
						"          points = nodesArray",
						"     )) ~> aggtest"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_way_point_agg')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "way > point agg ",
				"folder": {
					"name": "Belgium_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "ways"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "lines"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "aggtest"
						}
					],
					"transformations": [
						{
							"name": "waypointsstagging"
						},
						{
							"name": "aggregate1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          nodeid as long,",
						"          wayid as long,",
						"          tags as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select  unnest(w.nodes) as nodeid, w.id as wayId, cast(cast(w.tags as hstore) as json) as tags\\nfrom planet_osm_ways w',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> ways",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select uu_id , osm_id  from point_stagging ps ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"source(output(",
						"          osm_id as long,",
						"          way as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select abs(osm_id) as osm_id , way  from planet_osm_line pol ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> lines",
						"ways, pointstagging join(nodeid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> waypointsstagging",
						"waypointsstagging aggregate(groupBy(wayid,",
						"          tags),",
						"     nodesArray = collect(uu_id)) ~> aggregate1",
						"aggregate1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_point_agg',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          way_osm_id = wayid,",
						"          attributes = tags,",
						"          points = nodesArray",
						"     )) ~> aggtest"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_way_point_agg_admin_process')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "way > point agg ",
				"folder": {
					"name": "Belgium_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "ways"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "linepointagg"
						}
					],
					"transformations": [
						{
							"name": "waypointsstagging"
						},
						{
							"name": "aggregate1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          nodeid as long,",
						"          wayid as long,",
						"          tags as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select  unnest(w.nodes) as nodeid, w.id as wayId, cast(cast(w.tags as hstore) as json) as tags from planet_osm_ways w',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> ways",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select uu_id , osm_id  from point_stagging ps ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"ways, pointstagging join(nodeid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> waypointsstagging",
						"waypointsstagging aggregate(groupBy(wayid,",
						"          tags),",
						"     nodesArray = collect(uu_id)) ~> aggregate1",
						"aggregate1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_point_agg',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          way_osm_id = wayid,",
						"          attributes = tags,",
						"          points = nodesArray",
						"     )) ~> linepointagg"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_way_point_agg_admin_process_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "way > point agg ",
				"folder": {
					"name": "France_Admin"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "ways"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql3",
								"type": "LinkedServiceReference"
							},
							"name": "linepointagg"
						}
					],
					"transformations": [
						{
							"name": "waypointsstagging"
						},
						{
							"name": "aggregate1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          nodeid as long,",
						"          wayid as long,",
						"          tags as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select  unnest(w.nodes) as nodeid, w.id as wayId, cast(cast(w.tags as hstore) as json) as tags from planet_osm_ways w',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> ways",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select uu_id , osm_id  from point_stagging ps ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"ways, pointstagging join(nodeid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> waypointsstagging",
						"waypointsstagging aggregate(groupBy(wayid,",
						"          tags),",
						"     nodesArray = collect(uu_id)) ~> aggregate1",
						"aggregate1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_point_agg',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          way_osm_id = wayid,",
						"          attributes = tags,",
						"          points = nodesArray",
						"     )) ~> linepointagg"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_way_point_agg_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "way > point agg ",
				"folder": {
					"name": "India_Postal"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "ways"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "lines"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "aggtest"
						}
					],
					"transformations": [
						{
							"name": "waypointsstagging"
						},
						{
							"name": "aggregate1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          nodeid as long,",
						"          wayid as long,",
						"          tags as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select  unnest(w.nodes) as nodeid, w.id as wayId, cast(cast(w.tags as hstore) as json) as tags\\nfrom planet_osm_ways w',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> ways",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select uu_id , osm_id  from point_stagging ps ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"source(output(",
						"          osm_id as long,",
						"          way as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select abs(osm_id) as osm_id , way  from planet_osm_line pol ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> lines",
						"ways, pointstagging join(nodeid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> waypointsstagging",
						"waypointsstagging aggregate(groupBy(wayid,",
						"          tags),",
						"     nodesArray = collect(uu_id)) ~> aggregate1",
						"aggregate1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          way_osm_id as long,",
						"          points as string[],",
						"          attributes as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_point_agg',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          way_osm_id = wayid,",
						"          attributes = tags,",
						"          points = nodesArray",
						"     )) ~> aggtest"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_ways')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "ways"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "lines"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "linestagging"
						}
					],
					"transformations": [
						{
							"name": "waypointsstagging"
						},
						{
							"name": "aggregate1"
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          nodeid as long,",
						"          wayid as long,",
						"          tags as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select  unnest(w.nodes) as nodeid, w.id as wayId, cast(cast(w.tags as hstore) as json) as tags from planet_osm_ways w',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> ways",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select uu_id , osm_id  from point_stagging ps ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"source(output(",
						"          osm_id as long,",
						"          way as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select abs(osm_id) as osm_id , ST_AsText(way) as way from planet_osm_line pol ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> lines",
						"ways, pointstagging join(nodeid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> waypointsstagging",
						"waypointsstagging aggregate(groupBy(wayid,",
						"          tags),",
						"     nodesArray = collect(uu_id)) ~> aggregate1",
						"aggregate1, lines join(wayid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 derive(uuid = uuid()) ~> derivedColumn1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as string,",
						"          osm_id as long,",
						"          pointstext as string[],",
						"          pointsuuid as string[],",
						"          layer as string,",
						"          attributes as string,",
						"          metadata as string,",
						"          geometrytext as string,",
						"          geometry as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'line_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     stagingSchemaName: '',",
						"     store: 'postgres',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id = uuid,",
						"          osm_id = wayid,",
						"          attributes = tags,",
						"          pointstext = nodesArray,",
						"          geometrytext = way",
						"     )) ~> linestagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_ways_test')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Test"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "ways"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "pointstagging"
						},
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzurePostgreSql1",
								"type": "LinkedServiceReference"
							},
							"name": "waypointstagging"
						}
					],
					"transformations": [
						{
							"name": "waypointsjoin"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          nodeid as long,",
						"          wayid as long,",
						"          tags as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select  unnest(w.nodes) as nodeid, w.id as wayId, cast(cast(w.tags as hstore) as json) as tags\\nfrom planet_osm_ways w',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> ways",
						"source(output(",
						"          uu_id as string,",
						"          osm_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select uu_id , osm_id  from point_stagging ps ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> pointstagging",
						"source(output(",
						"          osm_id as long,",
						"          waygeomtext as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'query',",
						"     query: 'select  abs(osm_id) as osm_id , ST_AsText(way) as waygeomtext  from planet_osm_line pol ',",
						"     store: 'postgres',",
						"     isolationLevel: 'READ_COMMITTED') ~> source1",
						"ways, pointstagging join(nodeid == osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> waypointsjoin",
						"waypointsjoin, source1 join(wayid == source1@osm_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          node_uuid as string,",
						"          node_osm_id as long,",
						"          way_osm_id as long,",
						"          attributes as string,",
						"          geometry as string,",
						"          geometrytext as string",
						"     ),",
						"     format: 'table',",
						"     tableName: 'way_point_stagging',",
						"     schemaName: 'public',",
						"     deletable: false,",
						"     insertable: true,",
						"     updateable: false,",
						"     upsertable: false,",
						"     store: 'postgres',",
						"     postSQLs:['update way_point_stagging\\nset geometry = ST_GeomFromText(geometrytext)'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          attributes = tags,",
						"          node_osm_id = nodeid,",
						"          way_osm_id = wayid,",
						"          node_uuid = uu_id,",
						"          geometrytext = waygeomtext",
						"     )) ~> waypointstagging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzurePostgreSql1')]"
			]
		}
	]
}